Singleton Pattern

Yapı açısından signleton oldukça basittir. Bu, özel bir örnekelme ve bu örnekleme başvurmanın tek yolunu sağlayan bir statik yönteme sahip tek bir sınıftır. Ayrcıa private bir constructor'a sahip olmalıdır. Çünkü nesnenin dışarıdan üretilmemesi prensibine dayanmaktadır. Singleton deseninde esas amaç nesnenin her daim bir örneklem oluşturulması ve bu örneklerm üzerinden bütün işlemlerin yapılmasıdır. Biraz daha açarsak nesnenin kullanım süresi boyunca sadece bir kez oluşturulması ve bir daha oluşturulmaması üzerine kurulu bir mantığı vardır. 

Singleton modelinin doğası, onu uygulayan sınıfların bir uygulamamnın ömrü boyunca herhangi bir zamanda 0 veya 1 olmasıdır.Singleton sınıfları parametresiz oluşturulur. Farklı parametrelere dayalı çeşitli benzer örneklere ihtiyacınız varsa, muhtemel factory design pattern'i kullanmanız gerekir. 

Performans nedeniyle singleton nesneler genellikle birşey onlardan talep edilinceye kadar oluşturulmazlar. Bu lazy instantiation olarak bilinir ve bu kalıbın çoğu uygulaması tarafından varsayılan davranıştır. Ancak, uygulama başladığında ihtiyacımız olan örneği basitçe üretmek, oluşturmak ve ardından bu örneği uygulamanın ömrü boyunca kullanmaktda mümkündür. Singleton sınıflar tek, özel, parametresiz bir constructor'a sahip olmalıdır. 

Singleton'a yapılan tek referans, singleton sınıfının karakteristik özelliği özel bir satatik alanda olmasıdır. Uygulamanın geri kalanı, sınıfın amaç için gösterdiği genel bir statik yöntem aracılığıyla örnekleme erişir ve onu kullanır. 

Singleton ile üretilmiş nesnelerin kendisine has karakteristik bir yaşam döngüsü bulunmaktadır. Bu yüzden önümöüze gelen nesneleri singleton ile üretmemeliyiz. Singleton ile üretilen nesneler statik sınıflar gibi RAM üzerinde yaşam alanları biriciktir. RAM'in HEAP alanında yaşarlar lakin projenin koştuğu server reset edilinceye kadar yaşarlar. Bu durum memory maliyeti olarak bize geri döner. 

Singleton bazı kaynaklarda anti-pattern olarak geçer. Bunun nedeni uygulandıkları bir arabirimi iletmek yerine kodda doğrudan statik kullanıldıklarından sınıflar arasında tight couple bir ilişkiye sebebiyet verir. Private constructor ve statik yapıları yüzünden bağımlılık enjeksiyonuna(Dependency Injection(DI)) uygun değildirler. Ayrıca bu modeli takip eden sınfılar gerçek işlerinin yanı sıra örneklem yaşam sürelerini yönetmekten sorumlu olacağından, endişelerin ayrılması prensibine(seperation of concerns) ve tek sorumluluk ilkesine(Single Responsibility Principle(SIP)) ters düşmektedir. Birden fazla singleton uygulayacaksınız, singleton davranışı zorlamak için gerek tüm mantığı çoğaltmanız gerekecek, bu da aynı zamanda kendinizi tekrar etmeniz(DRY => Dont Repeat Yourself) ilkesinide ihlal ettiğiniz anlamına gelir. 